# Linux五种IO模型性能分析

## 概念理解
在进行网络编程时，我们常常见到同步(Sync)/异步(Async)，阻塞(Block)/非阻塞(Unblock)四种调用方式：
- 同步
    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做，等前一件做完后才能做下一件事。  
    例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回这个期间客户端浏览器不能干任何事

- 异步
    异步的概念和同步相对。当一个异步调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调通知调用者。    
    例如 ajax请求（异步）：请求通过时间触发->服务器处理(这时浏览器仍然可以做其他事情)-> 处理完毕

- 阻塞
    阻塞调用是指调用结果返回之前，当前线程会被挂起(线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行)。函数只有在得到结果后才会返回   
    有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才会返回。而此时，当前线程还会继续处理各种各样的消息。

- 非阻塞
    非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。  
    对象的阻塞模式和阻塞函数调用    
    对象是否处理阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞，而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用，函数select就是这样一个例子。

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我(回调通知)
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞
阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回

## Linux下的五种I/O模型
1. 阻塞I/O（blocking I/O）
2. 非阻塞I/O（nonblocking I/O）
3. I/O复用（select和poll）（I/O multiplexing）
4. 信号驱动I/O（signal driven I/O（SIGIO））
5. 异步I/O（asynchronous I/O（the POSIX aio_functions））

### 阻塞I/O
    同步阻塞I/O模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。    
    在这个IO模型中，用户空间的应用程序执行一个系统调用（recvfrom），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。直到kernel返回结果，用户进程才解除block状态，重新运行起来。 
    可以看出来，这两个阶段都被block住了。

![阻塞I/O模型图](https://raw.githubusercontent.com/gongthub/wiki/master/docs/Resources/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

### 非阻塞I/O
    在这种模式下，用户进程发出请求后，并不会阻塞，内核会里面返回一个error状态，然后用户进程需要轮询不断的check状态，在轮询期间可以干点别的事，最后直到内核把数据准备好了，然后通知用户进程，把数据从内核空间拷贝到用户所在的进程进行处理。

![非阻塞I/O模型图](https://raw.githubusercontent.com/gongthub/wiki/master/docs/Resources/%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

### I/O复用
    IO多路复用，指的是由专门的一个进程复制轮询检查IO操作的状态，而不用每个用户进程都得自己复制轮询，这样就大大节省了线程资源。那么这就是所谓的“IO多路复用”。UNIX/Linux下的select、poll、epoll就是干这个的（epoll比poll、select效率高，做的事情是一样的）。它的基本原理就是select、poll、epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 
    当用户进程调用了socket，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select、poll、epoll函数就可以返回

![I/O多路复用模型图](https://raw.githubusercontent.com/gongthub/wiki/master/docs/Resources/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

### 信号驱动I/O
    信号驱动I/O:首先我们允许socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据

![信号驱动I/O模型图](https://raw.githubusercontent.com/gongthub/wiki/master/docs/Resources/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

### 异步I/O
    相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制给进程，然后从内核向进程发送通知。IO两个阶段进程都是非阻塞的。  
    Linux提供了AIO库函数实现异步，但是用的很少。目前很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：

![异步I/O模型图](https://raw.githubusercontent.com/gongthub/wiki/master/docs/Resources/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)