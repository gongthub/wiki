# Java HashMap


## 问题
- 为什么要保证HashMap底层数组是2^n ？
    > 原因：减少碰撞次数  
    ```
    eg：假设底层数据长度为15，hashcode 有0,1,2,3,4,5
     则对应i计算为 ： h & (length-1)   ===> h & 14
         length-1      hashcode         index
     即：1110      &    0000     ===>   0000
         1110      &    0001     ===>   0000  (碰撞 1 次)
         1110      &    0010     ===>   0010  
         1110      &    0011     ===>   0010  (碰撞 2 次)
         ...           ....              ....
    由上述例子，可以发现，不管怎样 对应hashcode 最后一位都为0的都都访问不到 也就是说0001,0011,0101,0111,1001,1101,1111,1011 => 1,3,5,7,9,11,13,15为下标的元素都访问不到，浪费存储空间。

    而如果底层数据长度为2^n (eg :16)那么与之对应的index求取公式为 ：
            h & (16-1) = index 即  ： h & 1111 = index
    则对应的数据都能访问得到，减少了不同hash值的碰撞概率，并且能够使数据均匀分布，提高查询效率。
    ```